Exemplu:

pm.response.json() este jsonData sau response care este de fapt r.body
let status = jsonData[0].status deci status e de fapt r.body[0].status
sau poate fi si r.status (din supertest r.status si r.body)
// Unmatched Postman assertion: pm.expect(jsonData.length).to.eql(1);
.expect((r) => assert.ok(r.body.length == 1, 'Expected response message length to eql 1'));
// Unmatched Postman assertion: pm.expect\(jsonData.message\).to.eql\(.*\);
// Unmatched Postman assertion: pm.expect(jsonData.unauthorized_access.length).to.eql(1);
.expect((r) => assert.ok(r.body.unauthorized_access.length == 1));
.expect((r) => assert.ok(r.body.message.indexOf('Starting job') == 0));
.expect((r) => assert.ok(r.body.hasOwnProperty('4')));
.expect((r) => assert.equal(r.body[0]['COUNT(*)'], 350, `${generic.csv_tb} count was not 350`));
.expect((r) => assert.ok(r.body[0].status == 'IN_PROGRESS' || r.body[0].status == 0));
.expect((r) => assert.ok(r.body[0].status == 'ERROR'));
.expect((r) => assert.ok(r.body.length == 1));
.expect((r) => assert.ok(r.body.message.includes('inserted 1')))
.expect((r) => assert.ok(Object.keys(obj).length == 3))
//undefined null NaN empty string ("") false
.expect((r) => assert.ok(!value))
assert.OK merge si pentru assert not empty
====================================================================================



assert.ok(r.body == [])
CU:
assert.deepEqual(r.body, [])

deci:
assert.ok(r.body == [
CU:
assert.deepEqual(r.body, [

si:
assert.ok(r.body == {
CU:
assert.deepEqual(r.body, {


//Unmatched Postman assertion: jsonData.forEach(row => {


sa nu mai ramana nicaieri jsonData


sa caut dupa // Unmatched Postman assertion:
sa caut dupa //Unmatched Postman assertion
sa caut dupa Unmatched Postman assertion

sa ma uit la setTimeout( si sa pun await uri si sa fie inafara la await request()

sa inlocuiesc tot ce e cu: {{ , ca de exemplu {{schema}}, de ex:
{{username}} devine ${generic.username}
si "{{username}}" devine `${generic.username}`

sa caut si dupa: environment[" sau environment[

sa verific in .send() in json uri sa nu existe // adica commenturile din postman body, ca a pus comment uri ca si //

The targeted final format would look like this: https://github.com/HarperDB/harperdb/pull/2351/files

sa ma uit la setNextRequest

sa fie expect(<<STATUS CODE>>) tot timpul ultimul expect din metoda, inainte de ult rand:
});

import {setTimeout} from 'node:timers/promises';
//use always with async await setTimeout(x)

I don’t think it should be one massive test file, I think it should be split into groups roughly like it is currently in postman,
maybe something like - createDBandTable.js dataLoad.js sql.js noSql.js noSqlRole.js ……

You are repeating a lot of code inside each test. I wonder if you could wrap that in a reusable function? something like this perhaps
async function makeRequest(requestBody, expectedResponse, expectedStatus = 200) {
	const response = await request(envUrl).post('').set(headers).send(requestBody).expect(expectedStatus);

	if (expectedResponse) {
		assert.deepStrictEqual(response.body, expectedResponse, "Response body does not match expected output"); // Compare full response body
	}

	return response; // Return response in case more assertions are needed
}
or maybe
 	if (expectedResponse) {
 		response.expect((r) => assert.ok(r.body == expectedResponse))
 	}
Maybe use whatever assertions gives us the best error message when it fails? So that if we see it in the CI tests its clear what is wrong
looking at more of the tests maybe make expectedResponse an array so you can send it multiple assertions





