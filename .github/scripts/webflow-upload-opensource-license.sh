#!/usr/bin/env bash

set -euo pipefail

## Info:
# this script is used to generate, format, then upload to webflow this page: https://www.harperdb.io/legal/open-source-licenses-notices
# API calls documentation: https://developers.webflow.com/reference/
#
## Usage:
# Here is a list of env variables that can be set:
#   TOKEN - webflow API access token. created by jake@harperdb.io
#   API - just the base URL for the webflow api
#   LICENSE_FILE - path (relative or absolute) to the license file generated by harperdb/harperdb_opensource_license_generator. Should be in markdown
#   PUBLISH - utilizes the 'live' flag in the PATCH call (last api call) to make either a draft or publish the changes
#   SITE_SHORT_NAME - an account specific unique identifier in webflow that identifies https://harperdb.io
#   COLLECTION_SLUG - an account specific unique identifier in webflow that identifies the legal collection of pages on https://harperdb.io
#   ITEM_SLUG - an account specific unique identifier in webflow that identifies the open source license and notifications page on https://harperdb.io
#   ITEM_NAME - this value represents the header for the page being updated
#   MAX_NUMBER_FILES - the number of files to create with csplit. probably shouldn't be messed with
#   LINES_PER_CONTENT_FIELD - how many lines that csplit will create per file. this is mostly a guess on how much content we can fit into each content field.

# fail if we don't set TOKEN
[[ -z "${token}" ]] && echo "TOKEN not set" && exit 1

# this is for the live flag in the PATCH api call. defaults to false
publish=${PUBLISH:-false}
if ! [[ "${publish}" =~ ^(true|false)$ ]]; then 
  echo "invalid value for PUBLISH: ${publish}"
  exit 1
fi

dependencies=(curl pandoc jq)

# check for missing dependencies
missing_packages=""
for dependency in ${dependencies[@]}; do
  if ! command -v ${dependency} &> /dev/null; then
    missing_packages="${dependency} ${missing_packages}"
  fi
done

# attempt to install dependencies if we are in debian/ubuntu
if command -v apt-get &> /dev/null; then
  echo "installing ${missing_packages}"
  sudo apt-get -qq update
  sudo apt-get -qq -y install ${missing_packages}
fi

# verify dependencies
for package in ${missing_packages[@]}; do
  if ! command -v ${package} &> /dev/null
  then
      echo "required command ${package} could not be found"
      exit 1
  fi
done

# set up calling api
token="${TOKEN}"
api="${API:-https://api.webflow.com}"

# set names for the info we want to affect
site_short_name="${SITE_SHORT_NAME:-harperdb-official}"
collection_slug="${COLLECTION_SLUG:-legal}"

# we do have to know these ahead of time
item_slug="${ITEM_SLUG:-open-source-licenses-notices}"
item_name=${ITEM_NAME:-"Open Source Licenses & Notices"}

# output file from harperdb_opensource_license_generator
license_file=${LICENSE_FILE:-license.md}

# defaulting this at 9 for some growth, but also for using single digits in filename and content field
max_number_files=${MAX_NUMBER_FILES:-9}

# could be bumped if needed, but no idea how much
lines_per_content=${LINES_PER_CONTENT_FIELD:-5500}

# get site_id
site_id=$(curl --silent \
  --request GET \
  --url "${api}/sites?access_token=${token}" \
  --header 'accept: application/json'  \
  | jq -r ".[] | select(.shortName==\"${site_short_name}\") | ._id")

[ -z "${site_id}" ] && echo "failed to get site_id" && exit 1
echo "found site id as ${site_id}"

# get collection_id
collection_id=$(curl --silent \
  --request GET \
  --url "${api}/sites/${site_id}/collections?access_token=${token}" \
  --header 'accept: application/json' \
  | jq -r ".[] | select(.slug==\"${collection_slug}\") | ._id")

[ -z "${collection_id}" ] && echo "failed to get collection_id" && exit 1
echo "found collection id for legal collection slug as ${collection_id}"

# get item_id
item_id=$(curl --silent \
  --request GET \
  --url "${api}/collections/${collection_id}/items?access_token=${token}" \
  --header 'accept: application/json' \
  | jq -r ".items[] | select(.slug==\"${item_slug}\") | ._id")

[ -z "${item_id}" ] && echo "failed to get item_id" && exit 1
echo "found item id for os license item slug as ${item_id}"

# we are going to totally do things on the filesystem
directory="$(mktemp -d licenses-XXXX)"
prefix="content"

# generate license files
mkdir -p "${directory}"
pandoc --quiet \
  --from markdown \
  --to html \
  ${license_file} \
  | csplit \
    --silent \
    --keep-files \
    --elide-empty-files \
    --prefix=${directory}/${prefix}- \
    --digits=1 \
    - \
    ${lines_per_content} \
    '{7}' \
    2>/dev/null || true

# patch collection item
# add json for field to field for patch_data
patch_data=$(jq --null-input --argjson json "{}" '{fields: $json}')

## build patch/patch data
patch_data=$(echo ${patch_data} | jq --arg slug ${item_slug} '.fields += {slug: $slug}')
patch_data=$(echo ${patch_data} | jq --arg name "${item_name}" '.fields += {name: $name}')
patch_data=$(echo ${patch_data} | jq '.fields += {_archived: false}')
patch_data=$(echo ${patch_data} | jq '.fields += {_draft: true}')

# add files that we have to content fields
if [ -f "${directory}/${prefix}-0" ]; then
  new_content=$(cat ${directory}/${prefix}-0)
  patch_data=$(echo ${patch_data} | jq --arg content "${new_content}" '.fields += {content: $content}')
fi

if [ -f "${directory}/${prefix}-1" ]; then
  new_content=$(cat ${directory}/${prefix}-1)
  patch_data=$(echo ${patch_data} | jq --arg content "${new_content}" '.fields += {"content-2": $content}')
fi

if [ -f "${directory}/${prefix}-2" ]; then
  new_content=$(cat ${directory}/${prefix}-2)
  patch_data=$(echo ${patch_data} | jq --arg content "${new_content}" '.fields += {"content-3": $content}')
fi

if [ -f "${directory}/${prefix}-3" ]; then
  new_content=$(cat ${directory}/${prefix}-3)
  patch_data=$(echo ${patch_data} | jq --arg content "${new_content}" '.fields += {"content-4": $content}')
fi

if [ -f "${directory}/${prefix}-4" ]; then
  new_content=$(cat ${directory}/${prefix}-4)
  patch_data=$(echo ${patch_data} | jq --arg content "${new_content}" '.fields += {"content-5": $content}')
fi

if [ -f "${directory}/${prefix}-5" ]; then
  new_content=$(cat ${directory}/${prefix}-5)
  patch_data=$(echo ${patch_data} | jq --arg content "${new_content}" '.fields += {"content-6": $content}')
fi

if [ -f "${directory}/${prefix}-6" ]; then
  new_content=$(cat ${directory}/${prefix}-6)
  patch_data=$(echo ${patch_data} | jq --arg content "${new_content}" '.fields += {"content-7": $content}')
fi

if [ -f "${directory}/${prefix}-7" ]; then
  new_content=$(cat ${directory}/${prefix}-7)
  patch_data=$(echo ${patch_data} | jq --arg content "${new_content}" '.fields += {"content-8": $content}')
fi

if [ -f "${directory}/${prefix}-8" ]; then
  new_content=$(cat ${directory}/${prefix}-8)
  patch_data=$(echo ${patch_data} | jq --arg content "${new_content}" '.fields += {"content-9": $content}')
fi

echo "${patch_data}" | \
  curl --silent \
    --request PATCH \
    --url "${api}/collections/${collection_id}/items/${item_id}?live=${publish}&access_token=${token}" \
    --header 'accept: application/json' \
    --header 'content-type: application/json' \
    --data @-

